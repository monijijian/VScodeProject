### 什么是模块化
一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起。

模块的内部数据、实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。

最早的时候，我们会把所有的代码都写在一个js文件里，那么，耦合性会很高（关联性强），不利于维护；而且会造成全局污染，很容易命名冲突。

### 模块化的好处

- 避免命名冲突，减少命名空间污染

- 降低耦合性；更好地分离、按需加载

- 高复用性：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。

- 高可维护性：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。

- 部署方便

## 模块化规范
引入模块化，首先想到的可能是：在一个文件中引入多个js文件。
但这样会导致 
- 请求过多： 每次引入一个文件，就产生一次http请求
- 依赖模糊：不同的文件之间可能会相互依赖

**因此就产生了模块化规范**

模块化起源于 Node.js。Node.js 中把很多 js 打包成 package，需要的时候直接通过 require 的方式进行调用（CommonJS），这就是模块化的方式。

那如何把这种模块化思维应用到前端来呢？这就产生了两种伟大的 js：RequireJS 和 SeaJS。

### 服务器端规范

#### CommonJS规范

是Node.js使用的模块化规范，是一套约定标准，而非技术

### 浏览器端规范

#### AMD规范
是 RequireJS 在推广过程中对模块化定义的规范化产出

- 异步加载模块；

- 依赖前置、提前执行：require([`foo`,`bar`],function(foo,bar){});   //也就是说把所有的包都 require 成功，再继续执行代码。

- define 定义模块：define([`require`,`foo`],function(){return});

#### CMD规范
 是 SeaJS 在推广过程中对模块化定义的规范化产出。淘宝团队开发。

 同步加载模块； 依赖就近，延迟执行（）
 define 定义模块  ， export 导出